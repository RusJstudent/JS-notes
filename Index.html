<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Язык JavaScript</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
	<header>
		<button><a class="nav-link" href="browser.html" target="_blank">Браузер: документ, события, интерфейсы</a></button>
		<button><a class="nav-link" href="html+css.html" target="_blank">HTML + CSS</a></button>
		
		<h2>Содержание:</h2>
		
		<div class="_header">
			<ul id="content">
				<li><a href="#3">Основы JavaScript</a>
					<ul>
						<li><a href="#3.1">Преобразование типов</a></li>
						<li><a href="#3.2">Оператор "запятая"</a></li>
						<li><a href="#3.3">Оператор объединения с null '??'</a></li>
						<li><a href="#3.4">Метки для break/continue</a></li>
						<li><a href="#3.5">Функции</a></li>
					</ul>
				</li>
				<li><a href="#4">Объекты: основы</a>
					<ul>
						<li><a href="#4.1">Объекты</a></li>
						<li><a href="#4.2">Методы объектов</a></li>
						<li><a href="#4.3">Сборка мусора</a></li>
						<li><a href="#4.4">"this"</a></li>
						<li><a href="#4.5">Конструктор объекта</a></li>
						<li><a href="#4.6">Опциональная цепочка</a></li>
						<li><a href="#4.7">Тип данных Symbol</a></li>
						<li><a href="#4.8">Преобразование объектов в примитивы</a></li>
						<li><a href="#4.9">[object Object]</a></li>
					</ul>
				</li>
				<li><a href="#5">Типы данных</a>
					<ul>
						<li><a href="#5.1">Методы у примитивов</a></li>
						<li><a href="#5.2">Числа</a></li>
						<li><a href="#5.3">Математические функции</a></li>
						<li><a href="#5.4">Строки</a></li>
						<li><a href="#5.5">Массивы</a></li>
						<li><a href="#5.6">Методы массивов</a></li>
						<li><a href="#5.7">Перебираемые объекты</a></li>
						<li><a href="#5.8">Map и Set</a></li>
						<li><a href="#5.9">WeakMap и WeakSet</a></li>
						<li><a href="#5.10">Object.keys, values, entries</a></li>
						<li><a href="#5.11">Деструктурирующее присваивание</a></li>
						<li><a href="#5.12">Дата и время</a></li>
						<li><a href="#5.13">Формат JSON, метод toJSON</a></li>
					</ul>
				</li>
				<li><a href="#6">Продвинутая работа с функциями</a>
					<ul>
						<li><a href="#6.1">Рекурсия и стек</a></li>
						<li><a href="#6.2">Остаточные параметры и оператор расширения</a></li>
						<li><a href="#6.3">Замыкание</a></li>
						<li><a href="#6.4">Устаревшее ключевое слово "var"</a></li>
						<li><a href="#6.5">Глобальный объект</a></li>
						<li><a href="#6.6">Объект функции, NFE</a></li>
						<li><a href="#6.7">Синтаксис "new Function"</a></li>
						<li><a href="#6.8">Планирование: setTimeout и setInterval</a></li>
						<li><a href="#6.9">Декораторы и переадресация вызова, call/apply</a></li>
						<li><a href="#6.10">Привязка контекста к функции</a></li>
						<li><a href="#6.11">Каррирование</a></li>
						<li><a href="#6.12">Повторяем стрелочные функции</a></li>
					</ul>
				</li>
			</ul>
		</div>
	</header>

	<main>
		<pre>
<h1 id="3">Основы JavaScript</h1>
<p class='new-chapter' id="3.1">Преобразование типов</p>

Boolean():
"", 0, NaN, false, null, undefined === false
Остальное === true

Number():
"    123   " === 123
true == 1
false, null, "", " \t   "  === 0
undefined === NaN

<p class='new-chapter' id="3.2">Оператор "запятая"</p>

Оператор «запятая» предоставляет возможность вычислять несколько выражений, разделяя 
их запятой. Каждое выражение выполняется, но возвращается результат только последнего.
	let a = (1 + 2, 3 + 4); // a = 7
// Оператор "запятая" имеет самый низкий приоритет, поэтому скобки важны в приведенном примере.
	Без них в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7, 
	затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет игнорировано.

Иногда оператор используют в составе более сложных конструкций, 
чтобы сделать несколько действий в одной строке:
	for (a = 1, b = 3, c = a * b; a < 10; a++) {
		...
  	 }

<p class="new-chapter" id="3.3">Оператор объединения с null '??'</p>

Оператор объединения с null ?? — это быстрый способ выбрать первое «определённое» значение из списка.

Выражения «определено», если оно отличается от null или undefined.

Результат выражения a ?? b будет следующим:

a, если значение a определено,
b, если значение a не определено.


?? хорошо срабатывает чтобы выбрать первое "определенное" значение из списка.
	let height = 0;
	console.log(height || 100); // 100 (в данном случае || не сработал, нужно добавлять проверку на 0)
	console.log(height ?? 100); // 0


Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, 
поэтому при использовании его в выражении, скорее всего, потребуются скобки.

Запрещено использовать вместе с || или && без явно указанных круглых скобок.

<p class='new-chapter' id="3.4">Метки для break/continue</p>

Пример использования:

outer: for (let i = 0; i < 3; i++) {

	for (let j = 0; j < 3; j++) {
  
	do something....
  
	  // если cond, то выйти из обоих циклов
	  if (cond..) break outer; 
  
	  // сделать что-нибудь со значениями...
	}
  }


Метки не дают возможности передавать управление в произвольное место кода, лишь выйти из цикла.

Вызов break/continue возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

<p class='new-chapter' id="3.5">Функции</p>

<h3>Function declaration</h3>
function sayHi() {
	alert('Привет');
} 

<h3>Function expression</h3>
let sayHi = function() {
	alert('Привет');
};

<h3>Arrow functions</h3>
let sayHi = () => {
	alert('Привет');
};
let sayHi = n => n*2; // когда 1 аргумент, скобки ставить не нужно
// Более короткая запись для Function expression. Для 1 выражения return не нужен.

<h3>Anonymous functions</h3>
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); }, // Анонимная (безымянная) функция
  () => { alert("Вы отменили выполнение."); } // Еще одна анонимная функция
);

<h3>Отличия function declaration от function expression</h3>
1) Function declaration можно использовать во всем скрипте (или блоке кода, 
если функция объявлена в блоке), даже до ее объявления.
Функции, объявленные с помощью Function expression создаются только 
когда поток выполнения кода достигает их.

2) В строгом режиме, когда Function Declaration находится в блоке {...}, 
функция доступна везде внутри блока, но не снаружи него.
	if (true) {
  	function func() {
    	return 2;
  	}
	}

	console.log( func() ); // Error: func is not defined

[3) В браузере, если мы не используем модули, глобальные функции (объявленные 
глобально с помощью function declaration) становятся свойствами глобального объекта.]

<h3>Параметры по умолчанию</h3>
Если параметр не указан, то его значением становится undefined. Это не приведёт к ошибке:
	function showMessage(from, text) { // аргументы: from, text
		alert(from + ': ' + text);
  	}
	  showMessage("Аня"); // Aня: undefined

В вызове не указан параметр text, поэтому предполагается, что text === undefined.
Если мы хотим задать параметру text значение по умолчанию, мы должны указать его после =
	function showMessage(from, text = "текст не добавлен") {
		alert( from + ": " + text );
 	 }
 	 showMessage("Аня"); // Аня: текст не добавлен

<h1 id="4">Объекты</h1>
<p class='new-chapter' id="4.1">Объекты: основы</p>

Создание объекта:
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"


Если нужно менять имя свойства в зависимости от выполнения скрипта, 
то помогут квадратные скобки:
	let fruit = prompt("Какой фрукт купить?", "apple");

	let bag = {
  	[fruit]: 5, // имя свойства будет взято из переменной fruit
	};


Нет ограничений на имена свойств:
	let obj = {
 	 return: 1,
 	 let: 2
	};

	obj['for'] = 'hey';

	console.log( obj ); // {return: 1, let: 2, for: "hey"}


Проверить существование свойства можно с помощью оператора «in»
Синтаксис оператора: "key" in object


Цикл «for…in» используется для перебора всех свойств объекта.
	for (let key in obj) {
		alert( key );
		alert( obj[key] );
 	 }


Сравнение по ссылке
Операторы равенства == и строгого равенства === для объектов работают одинаково.
Два объекта равны только в том случае, если это один и тот же объект.


Клонирование и объединение объектов, Object.assign

Объединение:
	let user = { name: "Иван" };
	let permissions1 = { canView: true };
	let permissions2 = { canEdit: true };

	Object.assign(user, permissions1, permissions2);
	// теперь user = { name: "Иван", canView: true, canEdit: true }

Клонирование:
	let clone = Object.assign({}, user);


Вложенное клонирование
Можно осуществить с помощью рекурсии, либо использовать 
метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

<p class='new-chapter' id="4.2">Методы объектов</p>

1
user.sayHi = function() {
  alert("Привет!");
}; // Функцию, которая является свойством объекта, называют методом этого объекта.

2
user = {
  sayHi: function() {
    alert("Привет");
  }
}; // Cинтаксис для методов в литерале объекта

3
user = {
  sayHi() { // то же самое, что и "sayHi: function()"
    alert("Привет");
  }
}; // Сокращенная запись

<p class='new-chapter' id="4.3">Сборка мусора</p>

Сборка мусора
Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

Сборщик мусора «помечает» (запоминает) все корневые объекты.
Затем он идёт по их ссылкам и помечает все найденные объекты.
Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка 
от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
…И так далее, пока не будут посещены все ссылки (достижимые от корней).
Все непомеченные объекты удаляются.


<p class='new-chapter' id="4.4">"this"</p>

Вызов функции без объекта означает, что this == undefined
// в нестрогом режим this это глобальный объект

	function sayHi() {
 	 alert(this);
	}

	sayHi(); // undefined


В JavaScript this является «свободным», его значение вычисляется в момент 
вызова метода и не зависит от того, где этот метод был объявлен, а зависит 
от того, какой объект вызывает метод (какой объект стоит «перед точкой»).

Стрелочные функции особенные: у них нет своего «собственного» this. 
Если использовать this внутри стрелочной функции, то его значение 
берётся из внешней «нормальной» функции.
	let user = {
 	  firstName: "Илья",
 	  sayHi() {
 	    let arrow = () => alert(this.firstName);
  	    arrow();
 	  }
	};
	user.sayHi(); // Илья
// если бы вместо стрелочной использовали другое объявление функции, то в строгом режиме 
была бы ошибка, тк внешняя нормальная функция sayHi() не имеет своего собственного this
// Здесь arrow() использует значение this из внешнего метода user.sayHi()


<p class='new-chapter' id="4.5">Конструктор объекта</p>
До этого момента разбирался синтаксис "литерал объекта". Вспомним:
let user = {};  // синтаксис "литерал объекта"
let user = new Object(); // синтаксис "конструктор объекта"

<h3>Синтаксис "конструктор объекта"</h3>
Конструкторы следует вызывать при помощи оператора new. 
Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.
Вариант 1 (функция-конструктор с именем):
	function User(name) {
 	 this.name = name;
	}

	let user = new User('John');
// подходит для многоразового использования

Вариант 2 (анонимная функция-конструктор)
	let user = new function() {
 	this.name = "John";
	};
// можно использовать только один раз

<h3>Возврат значения из конструктора return</h3>
Если функция-конструктор возвращает примитивное значение, то оно будет отброшено. 
Если же возвращаемое значение - объект, то вместо this будет возвращён этот объект.
	let obj = {};

	function A() { return obj; }
	function B() { return obj; }

	alert( new A() == new B() ); // true

<p class='new-chapter' id="4.6">Опциональная цепочка</p>

Опциональная цепочка ?. останавливает вычисление и возвращает undefined, 
если часть перед ?. имеет значение undefined или null.

	let user = {}; // пользователь без свойства address
	alert(user.address.street); // ошибка!
	alert( user?.address?.street ); // undefined (без ошибки)

Переменная перед ?. должна быть объявлена
Если переменной user вообще не существует, то выражение user?.anything выдаст ошибку.

Другие варианты применения: ?.(), ?.[]
Например, ?.() используется для вызова потенциально несуществующей функции.
?.[] используется если значение свойства получаем с помощью квадратных скобок [], а не через точку.

[Кроме этого, ?. можно совместно использовать с delete:
delete user?.name; // Удалить user.name, если пользователь существует.] // работает и без ?.

<p class='new-chapter' id="4.7">Тип данных Symbol</p>

let id = Symbol(); // Создаём новый символ - id
let id = Symbol("id"); // Создаём символ id с описанием (именем) "id"

Символы уникальны (то есть не равны друг другу), даже если они имеют одинаковое описание.

Символы не преобразуются автоматически в строки.
	let id = Symbol("id");
	alert(id); // TypeError: Cannot convert a Symbol value to a string
	alert(id.toString()); // Symbol(id), теперь работает

Если нужно вывести описание символа:
	let id = Symbol('Я символ');
	console.log( id.description ); // Я символ


Чтобы записать новое символьное свойство, или обратиться к уже созданному, используют []:
	let user = {};
	let id = Symbol("id");
	user[id] = 1;
	console.log( user[id] ); // 1

Символы в литеральном объявлении объекта:
	let id = Symbol("id");

	let user = {
  	  [id]: 123
	};

Символы игнорируются циклом for…in
Object.keys(user) также игнорирует символы.
Object.assign копирует и строковые, и символьные свойства.


Глобальные символы
Иногда нужно, чтобы символы с одним именем были одной сущностью.
Например, разные части нашего приложения хотят получить доступ к символу "id".
Для этого существует глобальный реестр символов.
Для чтения из реестра используется вызов Symbol.for(key).
Он проверяет глобальный реестр и, при наличии в нём символа с именем key, 
возвращает его, иначе же создаётся новый символ Symbol(key) и записывается в реестр.

	let id = Symbol.for("id"); // если символа не существует, он будет создан
	// читаем символ из глобального реестра и записываем его в переменную

	let idAgain = Symbol.for("id");
	// читаем его снова в другую переменную (возможно, из другого места кода)

	alert( id === idAgain ); // true


Symbol.keyFor
Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, 
существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает 
глобальный символ и возвращает его имя.


Метод Object.getOwnPropertySymbols(obj) возвращает массив символьных ключей объекта.
Метод Reflect.ownKeys(obj) возвращает массив всех ключей объекта, включая символьные.
	
<p class='new-chapter' id="4.8">Преобразование объектов в примитивы</p>

Существует "три хинта", то есть 3 варианта преобразования объекта в примитив:
"string", "number", "default".

На практике все объекты кроме Date реализуют "default" так же, как и "number".
И если мы считаем "default" и "number" одинаковыми, как большинство 
встроенных объектов, то остаются всего два варианта преобразований.

В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:
obj[Symbol.toPrimitive](hint)
obj.toString()
obj.valueOf()

Порядок вызова:
Вызывает obj[Symbol.toPrimitive](hint) если такой метод существует, и передаёт ему хинт.

	Иначе, если хинт равен "string"
	пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.

	В случае, если хинт равен "number" или "default"
	пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.


Symbol.toPrimitive - это универсальный подход
Пример:
	let user = {
		name: "John",
		money: 1000,
  
		[Symbol.toPrimitive](hint) {
	 	 alert(`hint: ${hint}`);
	 	 return hint == "string" ? `{name: "${this.name}"}` : this.money;
		}
  	};
  
  	alert(user); // hint: string -> {name: "John"}
  	alert(+user); // hint: number -> 1000
  	alert(user + 500); // hint: default -> 1500


Методы toString/valueOf
Пример:
	let user = {
		name: "John",
		money: 1000,
  
		toString() {
	 	 return `{name: "${this.name}"}`;
		},
  
		valueOf() {
		  return this.money;
		}
  
 	 };
  
 	 alert(user); // toString -> {name: "John"}
 	 alert(+user); // valueOf -> 1000
 	 alert(user + 500); // valueOf -> 1500	

	// результат тот же что и при использовании Symbol.toPrimitive


На практике довольно часто достаточно реализовать только obj.toString() как «универсальный» 
метод для всех типов преобразований, возвращающий «читаемое» представление объекта, 
достаточное для логирования или отладки.
Пример:
	let user = {
		name: "John",
  
		toString() {
	 	 return this.name;
		}
  	};
  
 	alert(user); // toString -> John
	alert(user + 500); // toString -> John500

	// toString обработает все случаи преобразований к примитивам.
	
<p class='new-chapter' id="4.9">[object Object]</p>

Почему иногда мы получаем [object Object]?

Строковые представления типов в JavaScript строчные:
  typeof {} // "object"
Поэтому имеет смысл, что он начинается с [object...].

Все объекты имеют метод toString, который отображает что-то 
в формате [object type], где type - тип объекта.

Все объекты в JavaScript являются потомками Object // видимо речь о простых объектах.

<h1 id="5">Типы данных</h1>
<p class='new-chapter' id="5.1">Методы примитивов</p>

Примитив как объект
Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых 
значений и символов. Чтобы это работало, при таком доступе создаётся специальный 
«объект-обёртка», который предоставляет нужную функциональность, а после удаляется.


Метод Number.isInteger(num) возвращает true, если num - целое число, иначе false.

Метод toFixed(n) округляет число до n знаков после запятой и возвращает
строковое представление результата:

	let num = 3.56;
	let str = num.toFixed(1);
	console.log( typeof str ); // string

<p class='new-chapter' id="5.2">Числа</p>

Способы записи числа
console.log(7.3e3 === 7300); // true
console.log(-2e-2 === -0.02); // true

Шестнадцатеричные, двоичные и восьмеричные числа
0x - 16-ые, 0b - 2-ые, 0o - 8-ые.
Примеры: alert( 0xff ); // 255
	let num = 0b1111; // num = 15


Метод toString(base) возвращает строковое представление числа
в системе счисления base где base от 2 до 36. 
Примеры: let num = 255;
	console.log( num.toString(16) ); //ff
	console.log( 250..toString(2) ); // 2 точки для вызова метода
	console.log( (250).toString(2) ); // либо круглые скобки


Неточные вычисления
	alert( 0.1 + 0.2 == 0.3 ); // false
Число хранится в памяти в бинарной форме. 
Дроби, такие как 0.1 и 0.2 являются бесконечной дробью в двоичной форме.
В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную 
систему, так же, как нет возможности хранить одну третью в десятичной системе счисления.

Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит 
хранят позицию десятичной точки и один бит – знак. Eсли 52 бит не хватает на цифры, 
то при записи пропадут младшие разряды.
	alert( 9999999999999999 ); // 10000000000000000
	console.log(9999999999999999 === 1e16); // true


Проверка: isFinite и isNaN
Функция isNaN(value) преобразует значение в число и проверяет является ли оно NaN. 
Функция isFinite(value) преобразует аргумент в число и возвращает true, 
если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
	alert( isFinite("15") ); // true


Значение NaN уникально тем, что оно не равно ни чему:
	console.log( NaN == NaN ); // false

Метод Object.is(a, b) сравнивает значения как ===, но может работать с NaN и нулем:
console.log( Object.is(NaN, NaN) ); // true
console.log( Object.is(-0, 0) ); // false (технически эти значения разные)


parseInt и parseFloat
Функции «читают» число из строки. Если в процессе чтения возникает ошибка, 
они возвращают полученное до ошибки число. Функция parseInt возвращает 
целое число, а parseFloat возвращает число с плавающей точкой:
	alert( parseInt('100px') ); // 100
	alert( parseFloat('12.5em') ); // 12.5
	alert( parseFloat('12.3.4') ); // 12.3 (произойдёт остановка чтения на второй точке)

// возвращают NaN если первый символ - не число

parseInt(str, base) имеет необязательный второй параметр, определяющий систему счисления (от 2 до 36):
	alert( parseInt('2n9c', 36) ); // 123456

<h3>Основное</h3>
.toFixed(n) - метод, округляющий число до n знаков, возвращает результат в виде строки.
Неточные вычисления (числа хранятся в памяти в бинарное форме).
isFinite(value) - функция преобразует value в число и возвращает false (для NaN или бесконечности) либо true.
isNaN(value) - функция преобразует в число и если результат равен NaN, возвращает true.
isObject(a, b) - функция строго сравнивает 2 значения, работает с NaN в том числе.
parseInt и parseFloat - функции читают число (число с плавающей точкой) из строки и возвращают его.

<p class='new-chapter' id="5.3">Математические функции</p>

Math.floor - Округление в меньшую сторону
Math.ceil - Округление в большую сторону
Math.round - Округление до ближайшего целого
Math.trunc - Производит удаление дробной части без округления 
(не поддерживается в Internet Explorer)

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
alert( Math.random() ); // 0.1234567894322

Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.
alert( Math.max(3, 5, -10, 0, 1) ); // 5

Math.pow(n, power) - Возвращает число n, возведённое в степень power

<p class='new-chapter' id="5.4">Строки</p>

Кавычки
let single = 'single-quoted'; // одинарные
let double = "double-quoted"; // двойные
let backticks = `backticks`; // обратные

Обратные кавычки могут занимать более одной строки, в отличии от одинарных и двойных.

Спецсимволы
\n      Перевод строки для одинарных или двойных кавычек
\t	Знак табуляции
\', \"	Кавычки
\\	Обратный слеш ( \ )
\u{X…XXXXXX} Символ в кодировке UTF-32 Пример: \u{1F680} это 🚀


Длина строки
Свойство length содержит длину строки: alert( `My\n`.length ); // 3

<h3>Доступ к символам</h3>
1) С помощью метода str.charAt(pos). При отсутствии символа возвращает пустую строку.
2) C помощью квадратных скобок. При отсутствии символа возвращается undefined.
Примеры: let str = 'Hello';
	alert( str[0] ); // H
	alert( str.charAt(0) ); // H
	alert( str[str.length - 1] ); // o
	alert( str[1000] ); // undefined
	alert( str.charAt(1000) ); // '' (пустая строка)

3) Используя цикл for..of для перебора строки посимвольно:

	for (let char of "Hello") {
  	alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
	}

Строки неизменяемы, но можно создать новую строку и записать ее в ту же переменную:
	let str = 'Hi';
	str[0] = 'h'; // ошибка (нельзя изменять строку)
	str = 'h' + str[1]; // заменяем строку
	console.log( str ); // hi


<h3>Изменение регистра</h3>
Методы .toLowerCase() и .toUpperCase() возвращают строку в заданном регистре.
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
alert( 'Interface'[2].toUpperCase() ); // 'T' (перевод конкретного символа)


<h3>Поиск подстроки</h3>
Метод str.indexOf(substr, pos) ищет подстроку substr в строке str, начиная с позиции pos, 
и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.
	let str = 'Widget with id';
	console.log( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
	console.log( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
	console.log( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
	console.log( str.indexOf('id', 2) ) // 12
Метод str.lastIndexOf(substr, position) ищет с конца строки.

Побитовое НЕ ~
для 32-разрядных целых чисел значение ~n равно -(n+1)
	console.log( ~2 ); // -3, то же, что -(2+1)
	console.log( ~1 ); // -2, то же, что -(1+1)
	console.log( ~0 ); // -1, то же, что -(0+1)
	console.log( ~-1 ); // 0, то же, что -(-1+1)

Соответственно, прохождение проверки if ( ~str.indexOf("…") ) означает, что 
результат indexOf отличен от -1, совпадение есть. (Применяется в старом коде)


<h3>includes, startsWith, endsWith</h3>
Метод str.includes(substr, pos) возвращает true, 
если в строке str есть подстрока substr, либо false, если нет.
console.log( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3

Методы str.startsWith и str.endsWith проверяют, соответственно, 
начинается ли и заканчивается ли строка определённой строкой:
console.log( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
console.log( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

<h3>Получение подстроки</h3>
Метод str.slice(start, end) возвращает часть строки от start до (не включая) end.
	let str = "stringify";
	console.log( str.slice(0, 5) ); // 'strin'
	console.log( str.slice(2) ); // ringify, с позиции 2 и до конца
	console.log( str.slice(-4, -1) ); // gif
// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа

Метод str.substring(start, end) - почти такой же, но
1. можно задавать start больше end
2. отрицательные значение интерпретируются как 0.
	let str = "stringify";
	console.log( str.substring(6, 2) ); // "ring"
	console.log( str.substring(2, -3) ); // "st"

Метод str.substr(start, length) возвращает часть строки от start длины length.
let str = "stringify";
	console.log( str.substr(2, 4) ); // "ring"
	console.log( str.substr(-4, 2) ); // "gi"
// если задать отрицательную длину, то это равносильно length = 0

<h3>Стравнение строк</h3>
Строки кодируются в UTF-16. У любого символа есть соответствующий код.

Метод str.codePointAt(pos) возвращает код для символа, находящегося на позиции pos.
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90

Метод String.fromCodePoint(code) создаёт символ по его коду code.
alert( String.fromCodePoint(90) ); // Z

Метод str.localeCompare(str2) возвращает число, которое показывает, 
какая строка больше в соответствии с правилами языка:
Отрицательное число, если str меньше str2. Положительное число, если str больше str2.
0, если строки равны.
alert( 'Österreich'.localeCompare('Zealand') ); // -1

Метод str.trim() — убирает пробелы в начале и конце строки.
Метод str.repeat(n) — повторяет строку n раз.

<h3>Основное</h3>
str.length - свойство позволяет узнать длину строки.
for..of - цикл для перебора строки посимвольно.
str.indexOf(substr, pos) - метод для поиска подстроки начиная с позиции pos. Возвращает позицию или -1.
str.includes(substr, pos) - метод ищет substr начиная с pos. Возвращает true, если находит, либо false.
str.slice(start, end) - метод возвращает часть строки от start (включ-но) и до end (не включ-но).

<p class='new-chapter' id="5.5">Массивы</p>

<h3>Объявление</h3>

1) let arr = new Array();

Также можно сразу добавить эл-ты. Например:
	let arr = new Array("Яблоко", "Груша", "и тд");

Однако, если new Array вызывается с одним аргументом, который представляет 
собой число, он создаёт массив без элементов, но с заданной длиной.	

2) let arr = [];

<h3>Методы pop/push, shift/unshift</h3>
.pop() - удаляет последний элемент из массива и возвращает его.

.push(elem1, elem2...) - добавляет элемент (или несколько элементов) 
в конец массива и возвращает длину получившегося массива.


.shift() - удаляет из массива первый элемент и возвращает его:

.unshift(elem1, elem2...) - добавляет элемент (или несколько элементов) 
в начало массива и возвращает длину получившегося массива.

<h3>Перебор элементов массива</h3>
for (let i = 0; i < arr.length; i++) – работает быстрее всего.
for (let item of arr) – современный синтаксис только для значений элементов.


Простой способ очистить массив – это arr.length = 0 (свойство length 
можно вручную перезаписать. Если его уменьшить, массив станет короче)


toString
Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют 
только toString, который возвращает список элементов, разделенных запятыми:

	let arr = [1,2    ,  3]; // [1, 2, 3]
	console.log( arr.toString() ); // 1,2,3
	console.log( arr.toString() === String(arr) ); // true
	console.log( arr + 1 ); // 1,2,31

<p class='new-chapter' id="5.6">Методы массивов</p>

<h3>Добавление/удаление элементов</h3>
splice - arr.splice(index[, deleteCount, elem1, ..., elemN]) 
// удаляет deleteCount элементов начиная с index и заменяет на 
elemN эл-ты. Возвращает массив удаленных элементов.
Метод также может вставлять элементы без удаления если установить deleteCount в 0.


slice - arr.slice([start], [end])
// возвращает новый массив, в который копирует элементы, 
начиная с индекса start и до end (не включая end). 
arr.slice() без аргументов создаёт копию массива arr.


concat - arr.concat(arg1, arg2...)
// создаёт новый массив, в который копирует данные из других массивов 
и дополнительные значения. Другие объекты добавляются как есть.

	alert( arr.concat(arrayLike) ); // 1,2,[object Object]
…Но если объект имеет специальное свойство Symbol.isConcatSpreadable, 
то он обрабатывается concat как массив: вместо него добавляются его числовые свойства.
Для корректной обработки в объекте должны быть числовые свойства и length:
	let arr = [1, 2];

	let arrayLike = {
 	 0: "что-то",
 	 1: "ещё",
 	 [Symbol.isConcatSpreadable]: true,
 	 length: 2
	};

	alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё

<h3>Перебор: forEach</h3>
Метод forEach - arr.forEach(function(item, index, array) { ... });
// позволяет запускать функцию для каждого элемента массива.
Результат ф-ции, если она что-то возвращает, игнорируется.

	["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
 	 alert(`${item} имеет позицию ${index} в ${array}`);
	});

<h3>Поиск в массиве</h3>
indexOf/lastIndexOf и includes имеют одинаковый синтаксис и делают то же самое, 
что и их строковые аналоги, но работают с элементами вместо символов.

arr.indexOf(item, from) ищет item, начиная с индекса from, и 
возвращает индекс, на котором был найден искомый элемент, в противном случае -1.

arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.

arr.includes(item, from) – ищет item, начиная с индекса from, и 
возвращает true, если поиск успешен.
arr.includes правильно обрабатывает NaN в отличии от arr.indexOf и arr.lastIndexOf.



find и findIndex - arr.find(function(item, index, array) {...});
// находят элементы (индексы эл-тов) с определенным условием

find - Если функция возвращает true, поиск прерывается и возвращается 
item. Если ничего не найдено, возвращается undefined.

arr.findIndex - Возвращает индекс, на котором найден элемент или 
-1 если ничего не найдено.
	
	let users = [
 	 {id: 1, name: "Вася"},
 	 {id: 2, name: "Петя"},
 	 {id: 3, name: "Маша"}
	];
	let user = users.find(item => item.id == 1);
	alert(user.name); // Вася



filter - arr.filter(function(item, index, array) { ... });
// filter возвращает массив из всех подходящих элементов
Возвращается пустой массив в случае, если ничего не найдено.

<h3>Пребразование массива</h3>
map - arr.map(function(item, index, array) { ... });
// вызывает функцию для каждого элемента массива и возвращает массив 
результатов выполнения этой функции

	let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
	alert(lengths); // 5,7,6



sort(fn) - arr.sort()
// возвращает отсортированный массив, но обычно возвращаемое 
значение игнорируется, так как изменяется сам arr.

По умолчанию эл-ты сортируются как строки.
Чтобы использовать наш собственный порядок сортировки, нужно предоставить 
функцию в качестве аргумента arr.sort(), которая должна для пары значений возвращать:

function compare(a, b) {
  if (a > b) return 1; // 1 либо любое положительное число
  if (a == b) return 0; // не обязательно указывать
  if (a < b) return -1; // -1 либо любое отрицательное число
}

	arr.sort( (a, b) => (a > b) ? 1 : -1 ); // так запись короче
	arr.sort( (a, b) => a - b ); // очень короткая запись



reverse - arr.reverse()
Метод меняет порядок элементов в arr на обратный.
	arr.reverse();
Также возвращает измененный arr.



split - str.split(delim)
Разбивает строку на массив по заданному разделителю delim
Если delim не указан, возвращает всю строку в первом элементе массива.

У метода split есть необязательный второй числовой аргумент – ограничение на количество 
элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен.
	let arr = names.split(', ', 2);

join - arr.join(glue)
// Вызов arr.join(glue) делает в точности противоположное split. 
Возвращает строку из элементов arr, вставляя glue между ними (запятую если glue не указан).



reduce и reduceRight - arr.reduce(function(previousValue, item, index, array) {
 ... }, [initial]);
Методы используются для вычисления единого значения на основе всего массива.
// перебирают массив
// при вызове функции результат её вызова передается в previousValue
// первоначально previousValue берется из initial
// метод возвращает результат конечной функции

initial можно опустить, но в если массив будет пустой, возникнет ошибка
	let arr = [];
	arr.reduce((sum, current) => sum + current); // Error: Reduce of empty 
	array with no initial value

Если initial указан, но массив пустой, то возвращает initial.

Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.

<h3>Array.isArray</h3>
Метод используется чтобы отличить простой объект от массива

	alert(Array.isArray({})); // false
	alert(Array.isArray([])); // true



Большинство методов поддерживают «thisArg»
//Почти все методы массива, которые вызывают функции – такие как find, filter, map, 
за исключением метода sort, принимают необязательный параметр thisArg.
arr.find(func, thisArg); // пример
Значение параметра thisArg становится this для func.

	let army = {
 	  minAge: 18,
	  maxAge: 27,
 	  canJoin(user) {
  	  return user.age >= this.minAge && user.age < this.maxAge;
 	 }
	};

	let users = [
  	{age: 16},
  	{age: 20},
 	{age: 23},
	];

	// найти пользователей, для которых army.canJoin возвращает true
	let soldiers = users.filter(army.canJoin, army);
	console.log( soldiers );  // массив из двух объектов с age 20 и 23



Существуют и другие методы, например:

arr.some(fn)/arr.every(fn) проверяет массив.
Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все 
результаты вызовов являются true, то метод возвращает true, иначе false.

arr.fill(value, start, end) – заполняет массив повторяющимися value, 
начиная с индекса start до end.

arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start 
и заканчивая end, в собственную позицию target (перезаписывает существующие).

<p class='new-chapter' id="5.7">Перебираемые объекты</p>
Перебираемые (или итерируемые) объекты – это концепция, которая позволяет 
использовать любой объект в цикле for..of.

<h3>Symbol.iterator</h3>
Чтобы сделать объект итерируемым (и позволить for..of работать с ним), нам нужно добавить 
в объект метод с именем Symbol.iterator (специальный встроенный Symbol, созданный как раз для этого).

1. Когда цикл for..of запускается, он вызывает этот метод один раз (или выдаёт ошибку, 
если метод не найден). Этот метод должен вернуть итератор – объект с методом next.

2. Дальше for..of работает только с этим возвращённым объектом.

3. Когда for..of хочет получить следующее значение, он вызывает метод next() этого объекта.

4. Результат вызова next() должен иметь вид {done: Boolean, value: any}, где done=true 
означает, что итерация закончена, в противном случае value содержит очередное значение.

	let range = {
		from: 1,
		to: 5
	  };

	  // 1. вызов for..of сначала вызывает эту функцию
	  range[Symbol.iterator] = function() {
	
		// ...она возвращает объект итератора:
		// 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
		return {
		  current: this.from,
		  last: this.to,
		
		  // 3. next() вызывается на каждой итерации цикла for..of
		  next() {
			// 4. он должен вернуть значение в виде объекта {done:.., value :...}
			if (this.current <= this.last) {
			  return { done: false, value: this.current++ };
			} else {
			  return { done: true };
			}
		  }
		};
	  };

	  // работает
	  for (let num of range) {
		alert(num); // 1, затем 2, 3, 4, 5
	  }


<h3>Array.from</h3>
Метод Array.from принимает итерируемый объект (объект, который реализует 
метод Symbol.iterator) или псевдомассив (объект, у которого есть индексы 
и свойство length (в том числе строки)) и делает из него «настоящий» Array.
	Пример:
	let arrayLike = {
	  0: "Hello",
 	 1: "World",
 	 length: 2
	};
	let arr = Array.from(arrayLike); // (*)
	alert(arr.pop()); // World (метод работает)

Полный синтаксис Array.from позволяет указать необязательную «трансформирующую» функцию:
Array.from(obj[, mapFn, thisArg]);

	let arr = Array.from(range, num => num * num); // range взят из примера выше

<p class='new-chapter' id="5.8">Map и Set</p>
Перебор Map и Set всегда осуществляется в порядке добавления элементов, но 
поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

<h3>Map</h3>
Map – это коллекция пар ключ/значение, как и Object. 
Map позволяет использовать ключи любого типа.

Методы и свойства:
new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.


Цепочка вызовов
Каждый вызов map.set возвращает объект map, так что можно объединить вызовы в цепочку:

	map.set("1", "str1")
		.set(1, "num1")
		.set(true, "bool1");

<h3>Перебор Map</h3>
map.keys() – возвращает итерируемый объект по ключам
map.values() – возвращает итерируемый объект по значениям
map.entries() – возвращает итерируемый объект по парам вида 
	[ключ, значение], этот вариант используется по умолчанию в for..of.

Вместе с циклом for..of:
	let recipeMap = new Map([
 	 ["огурец", 500],
 	 ["помидор", 350],
 	 ["лук",    50]
	]);

	for (let vegetable of recipeMap.keys()) {
		alert(vegetable); // огурец, помидор, лук
	  }


Кроме этого, Map имеет встроенный метод forEach:
	recipeMap.forEach((value, key, map) => {
 	alert(`${key}: ${value}`); // огурец: 500 и так далее
	});

<h3>Object.entries: Map из Object</h3>
Метод Object.entries(obj) возвращает массив пар ключ-значение 
(то, что нужно для создания Map)
Способ 1:
	let map = new Map([
	['1',  'str1'],
	[1,    'num1'],
	[true, 'bool1']
	]);

	alert( map.get('1') ); // str1

Способ 2:
	let obj = {
 	 name: "John",
 	 age: 30
	};
	let map = new Map(Object.entries(obj));

<h3>Object.fromEntries: Object из Map</h3>
Метод Object.fromEntries получив массив пар вида 
[ключ, значение], создаёт из них объект:

	let obj = Object.fromEntries(map.entries());
или короче: let obj = Object.fromEntries(map);

<h3>Set</h3>
Объект Set – это особый вид коллекции: «множество» уникальных значений 
(без ключей), где каждое значение может появляться только один раз.

Методы и свойства:
new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен 
итерируемый объект (обычно это массив), то копирует его значения в новый Set.
set.add(value) – добавляет значение (если оно уже есть, 
то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если 
value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.

<h3>Перебор Set</h3>
Можно перебирать как с помощью метода for..of, так и используя forEach:
	let set = new Set(["апельсин", "яблоко", "банан"]);
	for (let value of set) alert(value);

	// то же самое с forEach:
	set.forEach((value, valueAgain, set) => {
 	 alert(value);
	});


Set имеет те же встроенные методы, что и Map:
set.values() – возвращает перебираемый объект для значений.
set.keys() – то же самое, что и set.values(),
присутствует для обратной совместимости с Map.
set.entries() – возвращает перебираемый объект для пар вида.
[значение, значение], присутствует для обратной совместимости с Map.



<p class='new-chapter' id="5.9">WeakMap и WeakSet</p>
Используются как вспомогательные структуры данных в дополнение к 
«основному» месту хранения объекта. 
Не являются перебираемыми.

<h3>WeakMap</h3>
Ключи в WeakMap должны быть объектами.

При использовании объекта в качестве ключа если больше 
нет ссылок на этот объект, он будет удалён из памяти (и из объекта 
WeakMap) автоматически вместе с соответствующим ему значением.

WeakMap не поддерживает перебор и методы keys(), values(), 
entries(), так что нет способа взять все ключи или значения из неё.

В WeakMap присутствуют только следующие методы:
weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)

Пример реализации счетчика посещений с помощью WeakSet:

	let visitsCountMap = new WeakMap(); // map: пользователь => число визитов

	// увеличиваем счётчик
	function countUser(user) {
 	 let count = visitsCountMap.get(user) || 0;
 	 visitsCountMap.set(user, count + 1);
	}

	После того, как объект john стал недостижим другими способами, кроме как через 
	WeakMap, он удаляется из памяти вместе с информацией по такому ключу из WeakMap.

<h3>WeakSet</h3>
По аналогии с WeakMap, в WeakSet можно добавлять только объекты.
Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.

WeakSet поддерживает следующие методы:
weakSet.add(value)
weakSet.has(value)
weakSet.delete(value)

<p class='new-chapter' id="5.10">Object.keys, values, entries</p>
Для простых объектов доступны следующие методы:
Object.keys(obj) – возвращает массив ключей.
Object.values(obj) – возвращает массив значений.
Object.entries(obj) – возвращает массив пар [ключ, значение].

Object.keys/values/entries игнорируют символьные свойства.

У объектов нет множества методов, которые есть в массивах, например map, filter и других.
Если нужно их применить, можно использовать Object.entries 
с последующим вызовом Object.fromEntries:
	Object.fromEntries(
	Object.entries(obj).map(([key, value]) => [key, value * 2])
	);

<p class='new-chapter' id="5.11">Деструктурирующее присваивание</p>
Это специальный синтаксис, который позволяет «распаковать» 
массивы или объекты в кучу переменных

<h3>Деструктуризация массива</h3>
	let arr = ["Ilya", "Kantor"]
	let [firstName, surname] = arr; // записывает firstName=arr[0], surname=arr[1]

Ненужные элементы массива также могут быть отброшены через запятую:
	let [firstName, , title] = ["Julius", "Caesar", "Consul", "..."];
	alert( title ); // Consul 

Можно использовать что угодно «присваивающее» с левой стороны:
	let user = {};
	[user.name, user.surname] = "Ilya Kantor".split(' ');
	alert(user.name); // Ilya

Цикл с entries:
	for (let [key, value] of Object.entries(user)) { // user - простой объект
		alert(`${key}:${value}`); // name:John, затем age:30
  	}

Остаточные параметры:
	let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "Me"];

	rest является массивом:
	alert(rest[0]); // Consul
	alert(rest[1]); // Me
	lert(rest.length); // 2

Если в массиве меньше значений, чем в присваивании, они считаются неопределёнными:

	let [firstName, surname] = [];
	alert(firstName); // undefined

Если необходимо указать значения по умолчанию, то можно использовать =
Они выполняются, только если значения отсутствуют:

	let [name = "Guest", surname = "Anonymous", info = prompt('')] = ["Julius"];
	alert(name);    // Julius (из массива)
	alert(surname); // Anonymous (значение по умолчанию)
	alert(info); // (результат prompt)

<h3>Деструктуризация объекта</h3> 
	let options = { title: "Menu" };
	let {width, height = prompt("height?"), title} = options;

	console.log(width);  // undefined (нет такого свойства)
	console.log(height); // (результат prompt)
	console.log(title);  // Menu

Можно присвоить свойство объекта переменной с другим названием:
	let options = { title: "Menu" }
	let { title: t } = options;
	alert(t); // "Menu"

Остаток объекта «…»
// Можно использовать троеточие, как и для массивов.
	let options = { title: "Menu", height: 200, width: 100 };

	let {title, ...rest} = options;

	console.log(rest) ; //  {height: 200, width: 100}


Вложенная деструктуризация:

	let options = { size: {width: 100, height: 200} };

	let {
	  size: {
		width: w,
		height,
		title = "Menu",
	  },
	} = options;

	console.log( size ) ; // error: size is not defined
	console.log( width ) ; // error: width is not defined
	console.log( w ) ; // 100
	console.log( title ) ; // "Menu"

<h3>Умные параметры функций</h3>
Есть ситуации, когда функция имеет много параметров, 
большинство из которых не обязательны. Например:

	function showMenu(title = "Untitled", width = 200, height = 100, items = []) {...}

Можно передать параметры как объект, и функция немедленно деструктурирует его в переменные:
	let options = {
	  title: "My menu",
	  items: ["Item1", "Item2"]
	};

	function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {...}
	showMenu(options);

Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:
	showMenu({}); // ок, все значения - по умолчанию
	showMenu(); // так была бы ошибка

Ошибку можно исправить, сделав {} значением по умолчанию для всего объекта параметров:
	function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
	  alert( `${title} ${width} ${height}` );
	}

	showMenu(); // Menu 100 200

	<p class='new-chapter' id="5.12">Дата и время</p>
Date - встроенный объект

<h3>Создание</h3>
1) new Date() без аргументов – создать объект Date с текущими датой и временем.

2) new Date(milliseconds), где milliseconds - таймстамп, то есть кол-во миллисекунд, 
прошедших с 1 января 1970 года.

3) new Date(datestring)

Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:
YYYY-MM-DD – это дата: год-месяц-день.
Символ "T" используется в качестве разделителя.
HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. 
Если указать просто букву Z, то получим UTC+0.
Возможны и более короткие варианты, например, YYYY-MM-DD, или даже YYYY.

	let date = new Date("2021-06-06");
	alert(date); // Sun Jun 06 2021 03:00:00 GMT+0300 (Москва, стандартное время)

4) new Date(year, month, date, hours, minutes, seconds, ms)
// обязательны только первые 2 аргумента
year должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет.
month начинается с 0 (январь) по 11 (декабрь).
Параметр date - день месяца. Если параметр не задан, то принимается значение 1.
Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.

	let date = new Date(2021, 5, 6, 8, 49);
	console.log( date ); // Sun Jun 06 2021 08:49:00 GMT+0300 (Москва, ...)

<h3>Получение компонентов даты</h3>
Значения в соответствии с местным часовым поясом.
Методы:
getFullYear() - Получить год (4 цифры).
getMonth() - Получить месяц, от 0 до 11.
getDate() - Получить день месяца, от 1 до 31.
getHours(), getMinutes(), getSeconds(), getMilliseconds() - соответственно названиям.
getDay() - Вернуть день недели от 0 (воскресенье) до 6 (суббота).

Значения по UTC:
getUTCFullYear(), getUTCMonth(), getUTCDate(), getUTCHours(), 
getUTCMinutes(), getUTCSeconds(), getUTCMilliseconds(), getDay()

	console.log( new Date().getHours() ); // 9
	console.log( new Date().getUTCHours() ); // 6


getTime() - Для заданной даты возвращает таймстамп
	console.log( new Date().getTime() ); // 1622959258175

getTimezoneOffset() - Возвращает разницу в минутах между местным часовым поясом и UTC:
	console.log( new Date().getTimezoneOffset() ); // -180

<h3>Установка компонентов даты</h3>
Методы:
setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) - устанавливает дату в виде целого кол-во ms, прошедших с 01.01.1970 UTC

	console.log( new Date().setHours(0) ); // 1622927664219

	let date = new Date(2021, 5, 6, 8, 49);
	date.setHours(0);
	console.log( date ); // Sun Jun 06 2021 00:49:00 GMT+0300 (Моск...)



Автоисправление даты
// Можно устанавливать компоненты даты вне обычного диапазона значений 
(даже нулевые или даже отрицательные), а объект сам себя исправит.
	let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
	alert(date); // ...1st Feb 2013!

Если нужно изменить дату:
	let date = new Date(2016, 1, 28);
	date.setDate(date.getDate() + 2);
	alert( date ); // 1 Mar 2016

Пример с нулевым значением:
	let date = new Date(2016, 0, 2); // 2 Jan 2016
	date.setDate(0); // выведется последнее число предыдущего месяца
	alert( date ); // 31 Dec 2015


Преобразование к числу, разность дат.
// Если объект Date преобразовать в число, то получим таймстамп по аналогии с date.getTime():
	console.log( +new Date() ); // 1622961034291

Поэтому даты можно вычитать, получая разность в миллисекундах. Пример:

	let start = new Date();
	for (let i = 0; i < 1e6; i++) {
	  let doSomething = i * i * i;
	}

	let end = new Date();
	console.log(`Цикл отработал за ${end - start} миллисекунд`)

Date.now()
// для быстрого получения текущего времени в формате таймстампа.
// семантически эквивалентен new Date().getTime(), но не создаёт промежуточный 
объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.
	
<h3>Бенчмаркинг</h3>
Например, нужно сравнить две функции, вычисляющие разницу 
между двумя датами: какая сработает быстрее?
Такие вычисления, замеряющие производительность называют «бенчмарками» (benchmark).

Для получения наиболее достоверных результатов тестирования 
производительности весь набор бенчмарков нужно запускать по нескольку раз.
Нелишним будет добавить предварительный запуск для «разогрева»:

	function diffSubtract(date1, date2) {
	  return date2 - date1;
	} // первая функция

	function diffGetTime(date1, date2) {
	  return date2.getTime() - date1.getTime();
	} // вторая функция

	function bench(f) {
	 let date1 = new Date(0);
	 let date2 = new Date();

	 let start = Date.now();
	 for (let i = 0; i < 100000; i++) f(date1, date2);
	  return Date.now() - start;
	} // функция, которая тестирует нужные нам функции

	let time1 = 0;
	let time2 = 0;

	// добавляем для "разогрева" перед основным циклом
	bench(diffSubtract);
	bench(diffGetTime);

	for (let i = 0; i < 10; i++) {
	  time1 += bench(diffSubtract);
	  time2 += bench(diffGetTime);
	} // запускаем по 10 раз для каждой функции тест

	console.log( 'Время diffSubtract: ' + time1 ); // 198
	console.log( 'Время diffGetTime: ' + time2 ); // 11



Разбор строки с датой
// Метод Date.parse(str) считывает дату из строки.
Формат такой же, как с синтаксисом new Date(datestring)

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп.
Если формат неправильный, возвращается NaN.

Дополнительно:
В браузерах есть метод performance.now(), возвращающий количество миллисекунд 
с начала загрузки страницы с точностью до микросекунд (3 цифры после точки):
	performance.now() // 8232.939999899827 (8 секунд)
// корректными являются только первые три цифры после точки, остальные - это ошибка точности.

<p class='new-chapter' id="5.13">Формат JSON, метод toJSON</p>
Преобразование сложных объектов в строки

Сам формат JSON:
Ключи объектов заключаются в двойные кавычки.
Значения, если это строки, также заключаются в двойные кавычки.

<h3>JSON.stringify</h3>
JSON.stringify - метод для преобразования объектов в JSON. 
Может быть применен к простым объектам, массивам, строкам, числам, логическим значениям и к null.
Пропускает методы, символьные функции, свойства, содержащие undefined.

Пример: {"name":"John","age":30}

	let user = {
 	 sayHi() { // будет пропущено
   	 alert("Hello");
  	},
  	[Symbol("id")]: 123, // также будет пропущено
  	something: undefined // как и это - пропущено
	};

	alert( JSON.stringify(user) ); // {} (пустой объект)

Ограничение: не должно быть циклических ссылок:
JSON.stringify(meetup); // Ошибка: Преобразование цикличной структуры в JSON

<h3>Исключаем и преобразуем: replacer</h3>
Полный синтаксис JSON: let json = JSON.stringify(value[, replacer, space])
value - Значение для кодирования.
replacer - Массив свойств для кодирования или функция соответствия function(key, value).
space - Дополнительное пространство (отступы), используемое для форматирования.

Вместо replacer можно передать массив свойств, которые мы хотим записать в JSON:
	let meetup = {
 	 title: "Conference",
 	 participants: [{name: "John"}, {name: "Alice"}],
	}

	alert( JSON.stringify(meetup, ['title', 'participants']) );
	// {"title":"Conference","participants":[{},{}]}
	// свойств name не будет, так как их нет в массиве свойств

Также на месте replacer можно написать функцию, а не массив. Она будет 
вызываться для каждой пары (key, value) и должна возвращать замененное значение 
вместо исходного, либо undefined чтобы пропустить значение.
	alert( JSON.stringify(meetup, function replacer(key, value) {
 	 alert(`${key}: ${value}`);
 	 return (key == 'occupiedBy') ? undefined : value;
	}));

Форматирование: space
space указывает на кол-во пробелов для удобного форматирования. Сделать это 
можно так:
	alert(JSON.stringify(user, null, 2));

<h3>Пользовательский «toJSON»</h3>
// Если объект имеет метод toJSON для преобразования в JSON, 
то он вызывается через JSON.stringify

	let room = {
	  number: 23,
  	  toJSON() {
    	    return this.number;
 	   }
	};

	let meetup = {
 	 title: "Conference",
 	 room
	};

	alert( JSON.stringify(meetup) ); // {"title":"Conference","room": 23}

<h3>JSON.parse</h3>
JSON.parse - метод для преобразования JSON обратно в объект.

Синтаксис: let value = JSON.parse(str, [reviver]);
str - это сам JSON для преобразования в объект
reviver - необязательная ф-ция, которая будет вызываться для каждой 
пары (ключ, значение) и преобразовывать значения.

Использование reviver
Чтобы значения объектов date не оставались строками после преобразования, 
надо использовать функцию:
	let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

	let meetup = JSON.parse(str, function(key, value) {
	  if (key == 'date') return new Date(value);
	  return value;
	});
// работает и для вложенных объектов

<h1 id="6">Продвинутая работа с функциями</h1>
<p class='new-chapter' id="6.1">Рекурсия и стек</p>

Рекурсия - это вызов функцией самой себя

	function pow(x, n) {
	  if (n == 1) {
 	   return x;
  	} else {
  	  return x * pow(x, n - 1);
  	}
	}

Рекурсивное решение задачи обычно короче, чем итеративное.

Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. 
В примере выше она будет равна ровно n.

Максимальная глубина рекурсии ограничена движком JavaScript. 
// обычно можно рассчитывать на 10000 вложенных вызовов.

Это ограничивает применение рекурсии, но она всё равно широко распространена: 
для решения большого числа задач рекурсивный способ решения даёт более простой 
код, который легче поддерживать.

<h3>Контекст выполнения, стек</h3>
Информация о процессе выполнения запущенной функции хранится в её 
контексте выполнения (execution context).

Контекст выполнения – специальная внутренняя структура данных, которая содержит 
информацию о вызове функции. Она включает в себя конкретное место в коде, на 
котором находится интерпретатор, локальные переменные функции, значение this 
и прочую служебную информацию.

Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:

Выполнение текущей функции приостанавливается.
Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – 
стеке контекстов выполнения.
Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
После их завершения старый контекст достаётся из стека, и выполнение внешней 
функции возобновляется с того места, где она была остановлена.

<h3>Пример: pow(2, 3)</h3>
В начале вызова pow(2, 3) контекст выполнения будет хранить 
переменные: x = 2, n = 3, выполнение находится на первой строке функции.
	Контекст: { x: 2, n: 3, строка 1 } (схематически)
строка
1	function pow(x, n) {
2	  if (n == 1) {
3 	  return x;
4  	} else {
5  	  return x * pow(x, n - 1);
6  	}
7	}

Условие n == 1 ложно, поэтому выполнение идёт во вторую ветку if.
актуальный контекст:
	Контекст: { x: 2, n: 3, строка 5 }

Чтобы вычислить выражение x * pow(x, n - 1), требуется произвести 
запуск pow с новыми аргументами pow(2, 2).

pow(2, 2)

Для выполнения вложенного вызова JavaScript запоминает 
текущий контекст выполнения в стеке контекстов выполнения.

Для любых функций процесс одинаков:

Текущий контекст «запоминается» на вершине стека.
Создаётся новый контекст для вложенного вызова.
Когда выполнение вложенного вызова заканчивается – контекст предыдущего 
вызова восстанавливается, и выполнение соответствующей функции продолжается.

Вид контекста в начале выполнения вложенного вызова pow(2, 2):
	Контекст: { x: 2, n: 2, строка 1 } - вызов pow(2, 2)
	Контекст: { x: 2, n: 3, строка 5 } - вызов pow(2, 3)

новый контекст находится на вершине стека, а предыдущие, запомненные - под ним.

pow(2, 1)

Процесс повторяется: производится новый вызов в строке 5, теперь с аргументами x=2, n=1.
Создаётся новый контекст выполнения, предыдущий контекст добавляется в стек:
	Контекст: { x: 2, n: 1, строка 1 } - вызов pow(2, 1)
	Контекст: { x: 2, n: 2, строка 5 } - вызов pow(2, 2)
	Контекст: { x: 2, n: 3, строка 5 } - вызов pow(2, 3)

Теперь в стеке 2 старых контекста и один текущий для pow(2, 1).

Выход
При выполнении pow(2, 1), в отличие от предыдущих запусков, условие n == 1 истинно, 
поэтому выполняется первая ветка условия if:
Вложенных вызовов больше нет, поэтому функция завершается, возвращая 2.
Когда функция заканчивается, контекст её выполнения больше не нужен, 
поэтому он удаляется из памяти, а из стека восстанавливается предыдущий:
	Контекст: { x: 2, n: 2, строка 5 } - вызов pow(2, 2)
	Контекст: { x: 2, n: 3, строка 5 } - вызов pow(2, 3)

Возобновляется обработка вызова pow(2, 2). Имея результат pow(2, 1), он может 
закончить свою работу x * pow(x, n - 1), вернув 4.

Восстанавливается контекст предыдущего вызова:
	Контекст: { x: 2, n: 3, строка 5 } - вызов pow(2, 3)

Самый внешний вызов заканчивает свою работу, его результат: pow(2, 3) = 8.
Глубина рекурсии в данном случае составила 3.

Глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.

<h3>Рекурсивный vs итеративный вариант</h3>
Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке.

В данном случае это приводит к тому, что возведение в степень n хранит в памяти n 
различных контекстов.
Итеративный вариант функции pow использует один контекст, в котором будут 
последовательно меняться значения. При этом объём затрачиваемой памяти небольшой, 
фиксированный и не зависит от n.

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.

Но переделка рекурсии в цикл может быть нетривиальной. 
Оптимизация может быть ненужной и совершенно нестоящей усилий.

Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. 
Оптимизация требуется не везде, как правило, важен хороший код, поэтому она и используется.

<h3>Пример: рекурсивные обходы</h3>
Другим отличным применением рекурсии является рекурсивный обход.
let company = {
 sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
 development: {
  sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
  internals: [{name: 'Jack', salary: 1300}]
}
};

function sumSalaries(department) { // Функция для подсчёта суммы зарплат
 if (Array.isArray(department)) { // конечный случай
  return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
 } else { // случай (2)
 let sum = 0;
 for (let subdep of Object.values(department)) {
	  sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
 }
 return sum;
}
}

console.log(sumSalaries(company)); // 6700

<h3>Рекурсивные структуры</h3>
Рекурсивная (рекурсивно определяемая) структура данных – это структура, 
которая повторяет саму себя в своих частях.

Рассмотрим рекурсивную структуру под названием «связанный список».

Связанный список
Например, нужно хранить упорядоченный список объектов. Естественным выбором будет массив:
let arr = [obj1, obj2, obj3];

…Но у массивов есть недостатки. Операции «удалить элемент» и «вставить элемент» являются 
дорогостоящими. (arr.shift(obj) или arr.unshift(obj) должны переиндексировать все элементы).
Массив будет довольно медленным для больших очередей, когда приходится работать с его началом.

Если нужны быстрые вставка/удаление, можно выбрать другую структуру данных, 
называемую связанный список.

Элемент связанного списка определяется рекурсивно как объект с:
value,
next – свойство, ссылающееся на следующий элемент связанного списка или null, 
если это последний элемент.

      let list = {
 	 value: 1,
 	 next: {
   	   value: 2,
   	   next: {
    	     value: 3,
     	     next: {
      	       value: 4,
      	       next: null
     		 }
   	      }
  	   }
	};


Пример 1: нужно вывести список по порядку:

function printList(list) {
   	alert(list.value); 
    
   if (list.next) {
     	printList(list.next);
   }
}

printList(list);

Пример 2: нужно вывести список в обратном порядке:

function printReverseList(list) {
   
    
    if (list.next) {
       printReverseList(list.next);
    }

    alert(list.value);
}

printReverseList(list);


Рекурсивное клонирование объекта: 
    function deepClone(obj) {
        let clone = {};
        for (let key in obj) {
            if (typeof obj[key] === 'object') {
                clone[key] = deepClone(obj[key]);
            } else {
                clone[key] = obj[key];
            }
        }
        return clone;
    }

<p class='new-chapter' id="6.2">Остаточные параметры и оператор расширения</p>
Многие встроенные функции JavaScript поддерживают произвольное количество аргументов:
Math.max(arg1, arg2, ..., argN)
Object.assign(dest, src1, ..., srcN)

<h3>Остаточные параметры (...)</h3>
Вызывать функцию можно с любым количеством аргументов независимо от того, 
как она была определена. Лишние аргументы не вызовут ошибку.
	let sum = (a, b) => a + b;
	console.log( sum(1, 2, 3, 4, 5) ); // 3

Остаточные параметры могут быть обозначены через три точки ... 
Буквально это значит: «собери оставшиеся параметры и положи их в массив».
	function sumAll(...args) { // args — имя массива
 	 let sum = 0;

 	 for (let arg of args) sum += arg;

 	 return sum;
	}

	alert( sumAll(1) ); // 1
	alert( sumAll(1, 2) ); // 3
	alert( sumAll(1, 2, 3) ); // 6

Остаточные параметры должны располагаться в конце
	function f(arg1, ...rest, arg2) { // arg2 после ...rest ?!
 	 // SyntaxError: Rest parameter must be last formal parameter
	}

<h3>Переменная "arguments"</h3>
Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.

function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // Объект arguments можно перебирать ( for (let arg of arguments) alert(arg); )
}

showName("Юлий", "Цезарь"); // Юлий, Цезарь

arguments все же не массив и не поддерживает методы массивов.

Для более удобной работы с аргументами лучше использовать остаточные параметры.

У стрелочных функций помимо this нет своего arguments.

<h3>Оператор расширения (spread)</h3>
Допустим, у нас есть массив чисел [3, 5, 1]. Как вызвать для него Math.max?
Просто так их не вставишь — Math.max ожидает получить список чисел, а не один массив.

Поможет оператор расширения. Он похож на остаточные параметры – тоже 
использует ..., но делает совершенно противоположное.
Когда ...arr используется при вызове функции, он «расширяет» перебираемый 
объект arr в список аргументов.
	let arr = [3, 5, 1];
	alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)

Этим способом можно передать несколько итерируемых объектов или 
комбинировать оператор расширения с обычными значениями:
	let arr1 = [1, -2, 3, 4];
	let arr2 = [8, 3, -8, 1];
	alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25

Оператор расширения можно использовать и для слияния массивов:
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)

Оператор расширения работает с любым перебираемым объектом.
Например, он подойдёт для того, чтобы превратить строку в массив символов:
	let str = "Привет";
	alert( [...str] ); // П,р,и,в,е,т


Array.from работает как с псевдомассивами, так и с итерируемыми объектами
Оператор расширения работает только с итерируемыми объектами

<h3>Итого</h3>
Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». 
Он собирает остальные неуказанные аргументы и делает из них массив.

Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». 
Он извлекает элементы из массива.

Остаточные параметры используются, чтобы создавать новые функции с 
неопределённым числом аргументов.
С помощью оператора расширения можно вставить массив в функцию, 
которая по умолчанию работает с обычным списком аргументов.

Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.

К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.

<p class='new-chapter' id="6.3">Замыкание</p>
<h3>Лексическое Окружение</h3>
В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с 
ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

Объект лексического окружения состоит из двух частей:
1. Environment Record – объект, в котором как свойства хранятся все локальные переменные 
(а также некоторая другая информация, такая как значение this).
2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду 
снаружи (снаружи от текущих фигурных скобок).

Лексическое окружение, связанное со всем скриптом называется глобальным.
У глобального лексического окружения нет внешнего окружения, то есть ссылка на внешнее 
лексическое окружение имеет значение null. 

Переменная – это свойство специального внутреннего объекта, 
связанного с текущим выполняющимся блоком/функцией/скриптом.
Работа с переменными – это на самом деле работа со свойствами этого объекта.

<h3>Внутреннее и внешнее лексическое окружение</h3>
	let phrase = "Hello";

	function say(name) {
	  alert( '${name}, ${phrase}` );
	}
	say("John");

В процессе вызова функции есть два лексических окружения: внутреннее 
(для вызываемой функции) и внешнее (глобальное):

Внутреннее лексическое окружение соответствует текущему выполнению say.
В нём находится одна переменная name, аргумент функции. Мы вызываем say("John"), 
так что значение переменной name равно "John" , то есть {name: "John"}
Во внешнем лексическом окружении находятся переменная phrase и сама функция.
У внутреннего окружения есть ссылка на внешнее.

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем 
лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к 
переменной, она берёт её текущее значение из своего или внешнего лексического окружения.

Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.
И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое 
окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

<h3>Вложенные функции</h3>
Функция называется «вложенной», когда она создаётся внутри другой функции.
	function makeCounter() {
	  let count = 0;

 	 return function() {
  	  return count++; // есть доступ к внешней переменной "count"
  	};
	}

	let counter1 = makeCounter();
	alert( counter1() ); // 0
	alert( counter1() ); // 1
	alert( counter1() ); // 2

	let counter2 = makeCounter();

	console.log( counter2() ); // 0
	console.log( counter2() ); // 1
// Для каждого вызова makeCounter() создаётся новое лексическое окружение функции, 
со своим собственным count. Так что, получившиеся функции counter – независимы.

	function Counter() {
	  let count = 0;

	  this.up = function() {
	    return ++count;
	  };
	  this.down = function() {
	    return --count;
	  };
	}

	let counter = new Counter();

	alert( counter.up() ); // 1
	alert( counter.up() ); // 2
	alert( counter.down() ); // 1
// Обе вложенные функции были созданы с одним и тем же внешним лексическим 
окружением, так что они имеют доступ к одной и той же переменной count

<h3>Окружение в деталях</h3>
Все функции «при рождении» получают скрытое свойство [[Environment]], 
которое ссылается на лексическое окружение места, где они были созданы.

В данном случае, makeCounter создана в глобальном лексическом окружении, 
так что [[Environment]] содержит ссылку на него.

Функция навсегда запоминает ссылку на лексическое окружение, где она была 
создана. И [[Environment]] – скрытое свойство функции, которое содержит эту ссылку.


Замыкание – это функция, которая запоминает свои внешние переменные 
и может получить к ним доступ. 
В JS все функции изначально являются замыканиями (исключение: функции, созданные 
с помощью "new Function", всегда ссылаются на глобальное лексическое окружение).
То есть, функции автоматически запоминают, где были созданы с помощью скрытого 
свойства [[Environment]]

<h3>Блоки кода и циклы</h3>
Функция в if:

let phrase = "Hello";

if (true) {
  let user = "John";

  function sayHi() {
    alert(`${phrase}, ${user}`);
  }
}

sayHi();

Когда выполнение попадает в блок if, для этого блока создаётся новое лексическое окружение.
У него есть ссылка на внешнее окружение, так что phrase может быть найдена. 
Но все переменные и Function Expression, объявленные внутри if, остаются в его 
лексическом окружении и не видны снаружи.


For, while
 // У каждой итерации цикла своё собственное лексическое окружение


Блоки кода
Можго использовать «простые» блоки кода {...}, чтобы изолировать 
переменные в «локальной области видимости».

Например, в браузере все скрипты (кроме type="module") разделяют одну общую глобальную 
область. Так что, если создать глобальную переменную в одном скрипте, она станет доступна 
и в других. Что может стать источником конфликтов (при использовании одной переменной).

Если мы хотим этого избежать, мы можем использовать блок кода 
для изоляции всего скрипта или какой-то его части:
	{
 	 // что-то делаем с локальными переменными, которые не должны быть видны снаружи
 	 let message = "Hello";
 	 alert(message); // Hello
	}
alert(message); // Ошибка: переменная message не определена


<h3>IIFE</h3>
В прошлом в JavaScript не было лексического окружения на уровне блоков кода.

Так что программистам пришлось что-то придумать. И то, что они сделали, 
называется «immediately-invoked function expressions» (аббревиатура IIFE), 
что означает функцию, запускаемую сразу после объявления.

IIFE выглядит так:

(function() {

  let message = "Hello";

  alert(message); // Hello

})();

Function Expression обёрнуто в скобки (function {...}), потому что, когда 
JavaScript встречает "function" в основном потоке кода, он воспринимает 
это как начало Function Declaration. Но у Function Declaration 
должно быть имя, так что такой код вызовет ошибку:

function() { // Error: Function statements require a function name

  let message = "Hello";

  alert(message); // Hello

}();

Однако, даже если добавить имя, это не сработает, потому что JavaScript не 
позволяет вызывает Function Delaration немедленно:

function go() {

}(); // Error: Unexpected token ')'


Кроме скобок, существуют и другие пути показать JavaScript, 
что мы имеем в виду Function Expression:

// Пути создания IIFE

(function() {
  alert("Скобки вокруг функции");
})();

(function() {
  alert("Скобки вокруг всего");
}());

!function() {
  alert("Выражение начинается с логического оператора NOT");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();

<h3>Сборка мусора</h3>
Объект лексического окружения умирает, когда становится недоступным 
(как и любой другой объект). Другими словами, он существует только до того момента, 
пока есть хотя бы одна вложенная функция, которая ссылается на него.

function f() {
  let value = Math.random();

  function g() { alert(value); }

  return g;
}

let random1 = f();
let random2 = f();
// две функции, каждая из них ссылается на лексическое окружение из 
соответствующего вызова f()

let random1 = null; // память соответствующего лексического окружения очищена

<h3>Оптимизация на практике</h3>
В теории, пока функция жива, все внешние переменные тоже сохраняются.
Но на практике движки JavaScript пытаются это оптимизировать. 
Они анализируют использование переменных и, если легко по коду понять, 
что внешняя переменная не используется – она удаляется.

Одним из важных побочных эффектов в V8 (Chrome, Opera) является то, 
что такая переменная становится недоступной при отладке.

Это может приводить к забавным (если удаётся решить быстро) проблемам при отладке. 
Одна из них – мы можем увидеть не ту внешнюю переменную при совпадающих названиях:

let value = "Сюрприз!";

function f() {
  let value = "ближайшее значение";

  function g() {
    debugger; // в консоли: напишите alert(value); Сюрприз!
  }

  return g;
}

let g = f();
g();

<p class='new-chapter' id="6.4">Устаревшее ключевое слово "var"</p>
Для «var» не существует блочной области видимости. Область видимости переменных 
var ограничивается либо функцией, либо, если переменная глобальная, то скриптом. 
Такие переменные доступны за пределами блока.

	for (var i = 0; i < 10; i++) {
 	 // ...
	}
	alert(i); // 10, переменная i доступна вне цикла, т.к. является глобальной


Если блок кода находится внутри функции, 
то var становится локальной переменной в этой функции:

	function sayHi() {
 	   if (true) {
  	     var phrase = "Привет";
 	   }
 	 alert(phrase); // срабатывает и выводит "Привет"
	}

	alert(phrase); // Ошибка: phrase не определена


«var» обрабатываются в начале запуска функции:

	function sayHi() {
 	 phrase = "Привет"; // (*)
 	 if (false) {
  	   var phrase;
  	  }
 	 alert(phrase);
	}

	sayHi();

Это поведение называется «hoisting» (всплытие, поднятие), 
потому что все объявления переменных var «всплывают» в самый верх функции.

Условие if (false) никогда не выполнится. Но это не препятствует созданию переменной 
var phrase, которая находится внутри него, поскольку объявления var «всплывают» 
в начало функции. Т.е. в момент присвоения значения (*) переменная уже существует.


Объявления переменных «всплывают», но присваивания значений – нет.

	function sayHi() {
 	 alert(phrase);
 	 var phrase = "Привет";
	}

	sayHi(); // получится alert(undefined)

Объявление переменной обрабатывается в начале выполнения функции («всплывает»), 
однако присвоение значения всегда происходит в той строке кода, 
где оно указано. Т.е. код выполняется по следующему сценарию:

Вызов alert происходил без ошибки, потому что переменная phrase 
уже существовала. Но её значение ещё не было присвоено, поэтому получали undefined.


Существует 2 основных отличия var от let/const:
1. Переменные var не имеют блочной области видимости, они ограничены 
телом функции, либо скриптом, если переменная глобальная.
2. Объявления (инициализация) переменных var производится в начале исполнения 
функции (или скрипта для глобальных переменных).
3. (из следующей главы) Глобальные переменные, объявленные с помощью var становятся 
свойствами глобального объекта.

<p class='new-chapter' id="6.5">Глобальный объект</p>
Глобальный объект хранит переменные и функции, доступные в любом месте 
программы. По умолчанию это те, что встроены в язык или среду исполнения.

В браузере он называется window, в Node.js — global, 
в другой среде исполнения может называться иначе.

Недавно globalThis был добавлен в язык как стандартизированное имя для глобального объекта.

Далее мы будем использовать window, полагая, что наша среда – браузер. 
Если скрипт может выполняться и в другом окружении, лучше будет globalThis.

Ко всем свойствам глобального объекта можно обращаться напрямую:
	window.alert("Привет"); // то же, что и просто alert("Привет")
	window.innerHeight // высота окна браузера

В браузере глобальные функции и переменные, объявленные с помощью var 
(не let/const!), становятся свойствами глобального объекта (*):
	var name = 'Sergey';
	let age = 23;
	console.log( window.name ); // Sergey
	console.log( window.age ); // undefined
// (*) Такое поведение поддерживается для совместимости и в современных 
проектах, использующих JavaScript-модули, такого не происходит.

Если свойство настолько важное, что нужно сделать его доступным для всей программы, 
то, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться 
к свойствам глобального объекта напрямую:
	window.currentUser = {
 	 name: "John"
	};
	console.log(currentUser.name); // John (либо window.currenUser.name)


Использование для полифилов.
Глобальный объект можно использовать, чтобы проверить поддержку современных 
возможностей языка:
	if (!window.Promise) { // проверка наличия встроенного объекта Promise
 	 window.Promise = ... // собственная реализация современной возможности языка
	} // создаем полифил и добавляем функции, существующие в современном стандарте

<p class='new-chapter' id="6.6">Объект функции, NFE</p>	
В JavaScript функция – это значение.
Каждое значение в JavaScript имеет свой тип. А функция – это какой тип?
В JavaScript функции – это объекты.
Функции можно не только вызывать, но и использовать их как обычные объекты: 
добавлять/удалять свойства, передавать их по ссылке и т.д.

<h3>Свойство «name»</h3>
Например, имя функции нам доступно как свойство «name»:
	function sayHi() {
	}
	console.log( sayHi.name );

Это работает даже в случае присваивания значения по умолчанию:
	function f(sayHi = function() {}) {
  	  alert(sayHi.name); // sayHi (работает!)
	}
	f();

Также имена имеют и методы объекта:
	let user = {
 	 sayHi() { ...
  	},
  	 sayBye: function() { ...
  	}
	}
	alert(user.sayHi.name); // sayHi
	alert(user.sayBye.name); // sayBye

Когда корректное имя определить невозможно, свойство name имеет пустое значение:
	let arr = [function() {}];
	console.log(arr[0].name); // пустая строка

<h3>Свойство «length»</h3>
Встроенное свойство «length» содержит количество параметров функции в её объявлении.
	function f1(a) {}
	function f2(a, b) {}
	function many(a, b, ...more) {}

	alert(f1.length); // 1
	alert(f2.length); // 2
	alert(many.length); // 2
Троеточие, обозначающее «остаточные параметры», здесь как бы «не считается»


	function ask(question, ...handlers) {
  	  let isYes = confirm(question);

 	  for(let handler of handlers) {
  	    if (handler.length == 0) {
     		if (isYes) handler();
    	    } else {
      		handler(isYes);
   	   }
 	 }
	}
	// для положительных ответов вызываются оба типа обработчиков
	// для отрицательных - только второго типа
	ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));

Это частный случай так называемого Ad-hoc-полиморфизма – обработка аргументов 
в зависимости от их типа или, как в нашем случае – от значения length.

<h3>Пользовательские свойства</h3>
Можно добавить свои собственные свойства:
	function sayHi() {
 	  alert("Hi");
  	  sayHi.counter++;  // посчитаем, сколько вызовов мы сделали
	}
	sayHi.counter = 0; // начальное значение
	sayHi(); // Hi
	sayHi(); // Hi
	alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза


Иногда свойства функции могут использоваться вместо замыканий. 
Например, можно переписать функцию-счётчик из главы Замыкание, используя её свойство:

	function makeCounter() {

	   function counter() {
  	     return counter.count++;
  	  };

 	  counter.count = 0;
	  return counter;
	}

	let counter = makeCounter();
	alert( counter() ); // 0
	alert( counter() ); // 1

Отличие в том, что если оно присвоено как свойство функции, то мы можем его получить:
counter.count = 10;
alert( counter() ); // 10

Если же значение count живёт во внешней переменной (как в главе Замыкание), 
то оно не доступно для внешнего кода. 

<h3>Named Function Expression</h3>
Named Function Expression или NFE – это термин для Function Expression, 
у которого есть имя.

Например, объявим Function Expression:
	let sayHi = function(who) {
 	  alert(`Hello, ${who}`);
	};

И присвоим ему имя:
	let sayHi = function func(who) {
 	  alert(`Hello, ${who}`);
	};
Функция всё ещё задана как Function Expression. 
Добавление "func" после function не превращает объявление в Function Declaration, 
потому что оно все ещё является частью выражения присваивания.
Добавление такого имени ничего не ломает, функция доступна как sayHi()

Есть две важные особенности имени func, ради которого оно даётся:
1. Оно позволяет функции ссылаться на себя же.
2. Оно не доступно за пределами функции.

	let sayHi = function func(who) {
 	   if (who) {
   	   alert(`Hello, ${who}`);
  	  } else {
  	   func("Guest"); // использует func, чтобы снова вызвать себя же (*)
  	  }
	};
	sayHi(); // Hello, Guest
	func(); // Ошибка, func не определена (недоступна вне функции)

(*) Если для вложенного вызова вместо func использовать sayHi, то в случае присвоения 
sayHi другого значения, функция "сломается"
let welcome = sayHi;
sayHi = null;
welcome(); // Error: sayHi is not a function

<p class='new-chapter' id="6.7">Синтаксис "new Function"</p>	

Существует ещё один вариант объявлять функции. Синтаксис:
let func = new Function([arg1, arg2, ...argN], functionBody);
Пример 1:
	let sum = new Function('a', 'b', 'return a + b');
	alert( sum(1, 2) ); // 3
Пример 2:
	let sayHi = new Function('alert("Hello")');
	sayHi(); // Hello

new Function позволяет превратить любую строку в функцию. 
Например, можно получить новую функцию с сервера и затем выполнить её:

	let str = ... код, полученный с сервера динамически ...
	let func = new Function(str);
	func();

<h3>Замыкание</h3>
Когда функция создаётся с использованием new Function, в её [[Environment]] записывается 
ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
Поэтому такая функция имеет доступ только к глобальным переменным:

	function getFunc() {
 	  let value = "test";
 	  let func = new Function('alert(value)');
 	  return func;
	}

	getFunc()(); // Error: value is not defined

Сравним это с обычным объявлением:
	function getFunc() {
	  let value = "test";
	  let func = function() { alert(value); };
  	  return func;
	}

	getFunc()(); // "test" (из лексического окружения функции getFunc)

Эта особенность new Function выглядит странно, но оказывается очень полезной на практике.
Перед отправкой JavaScript-кода на реальные работающие проекты код сжимается с помощью 
минификатора – специальной программы, которая уменьшает размер кода, удаляя комментарии, 
лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена.

Например, если в функции объявляется переменная let userName, то минификатор изменяет 
её на let a (или другую букву, если она не занята) и изменяет её везде. Обычно так 
делать безопасно, потому что переменная является локальной, и никто снаружи не имеет 
к ней доступ. И внутри функции минификатор заменяет каждое её упоминание.
Если бы new Function имела доступ к внешним переменным, были бы проблемы с минификаторами.
Кроме того, такой код был бы архитектурно хуже и более подвержен ошибкам.

По историческим причинам аргументы также могут быть объявлены через 
запятую в одной строке.
Эти 3 объявления ниже эквивалентны:
new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке

<p class='new-chapter' id="6.8">Планирование: setTimeout и setInterval</p>	
Можно вызвать функцию не в данный момент, а позже, через заданный интервал времени. 
Это называется «планирование вызова».

Для этого существуют два метода:
setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
setInterval позволяет вызывать функцию регулярно, повторяя вызов через 
определённый интервал времени.

Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения 
JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. 
В частности, они поддерживаются во всех браузерах и Node.js.

<h3>setTimeout</h3>
Синтаксис:
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

func|code
Функция или строка кода для выполнения. Обычно это функция. 
По историческим причинам можно передать и строку кода, но это не рекомендуется.

delay
Задержка перед запуском в миллисекундах. Значение по умолчанию – 0.

arg1, arg2…
Аргументы, передаваемые в функцию.

Например, данный код вызывает sayHi() спустя одну секунду:
	function sayHi(phrase, who) {
  	  alert( phrase + ', ' + who );
	}
	setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон


Если первый аргумент является строкой, то JavaScript создаст из неё функцию.
	setTimeout("alert('Привет')", 1000);

Но использование строк не рекомендуется. Вместо этого лучше использовать функции:
	setTimeout(() => alert('Привет'), 1000);


Отмена через clearTimeout
Вызов setTimeout возвращает «идентификатор таймера» timerId, 
который можно использовать для отмены дальнейшего выполнения.

let timerId = setTimeout(...);
clearTimeout(timerId);

<h3>setInterval</h3>
Метод setInterval имеет такой же синтаксис как setTimeout:
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

Функция запускается не один раз, а периодически через указанный интервал времени.
Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId)

Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
	let timerId = setInterval(() => alert('tick'), 2000);
	// повторить с интервалом 2 секунды

	setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
	// остановить вывод через 5 секунд
	// Во время показа alert время тоже идёт

<h3>Рекурсивный setTimeout</h3>
Метод setTimeout выше планирует следующий вызов прямо после окончания текущего:
	let timerId = setTimeout(function tick() {
 	  alert('tick');
  	  timerId = setTimeout(tick, 2000); // (*)
	}, 2000);

Рекурсивный setTimeout позволяет задать задержку между выполнениями более точно, 
чем setInterval.
Реальная задержка между вызовами func с помощью setInterval меньше, 
чем указано в коде, потому что время, затраченное на выполнение func, 
использует часть заданного интервала времени.
Рекурсивный setTimeout гарантирует фиксированную задержку.

Сборка мусора и колбэк setTimeout/setInterval
Когда функция передаётся в setInterval/setTimeout, 
на неё создаётся внутренняя ссылка и сохраняется в планировщике. 
Это предотвращает попадание функции в сборщик мусора, даже если на неё нет других ссылок.


<h3>setTimeout с нулевой задержкой</h3>
Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
Это планирует вызов func настолько быстро, насколько это возможно. 
Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.

	setTimeout('console.log("Привет")');
	for (let i = 0; i < 1000; i++) {
  	   console.log('hey');
	} // hey (1000 times); Привет

Ограничение браузера для setInterval и вложенных setTimeout: после 
пяти и более вложенных вызовов интервал должен составлять минимум 4 мс.

Все методы планирования не гарантируют точную задержку. Таймер в браузере 
может замедляться по многим причинам, например, если перегружен процессор.

<p class='new-chapter' id="6.9">Декораторы и переадресация вызова, call/apply</p>	
<h3>Прозрачное кеширование</h3>
Допустим, есть функция slow(x), выполняющая ресурсоемкие вычисления, но возвращающая 
стабильные результаты (для одного и того же x один результат).
Если функция вызывается часто, мы хотим запоминать (кешировать) возвращаемые ею 
результаты чтобы не делать повторных вычислений.
Вместо того, чтобы ее усложнять, заключим ее в функцию-обертку "wrapper", которая добавит 
кеширование:	
function slow(x) {
  alert(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {    // если кеш содержит такой x,
      return cache.get(x); // читаем из него результат
    }

    let result = func(x); // иначе, вызываем функцию

    cache.set(x, result); // и кешируем (запоминаем) результат
    return result;
  };
}

slow = cachingDecorator(slow);

alert( slow(1) ); // Called with 1; 1 // slow(1) кешируем
alert( "Again: " + slow(1) ); // Again: 1 //возвращаем из кеша

cachingDecorator – это декоратор, специальная функция, которая принимает другую 
функцию и изменяет её поведение. Идея состоит в том, что можно вызвать cachingDecorator 
с любой функцией, в результате чего получим кеширующую обёртку.
Отделяя кеширующий код от основного кода, также сохраняем чистоту и простоту последнего.


<h3>Применение «func.call» для передачи контекста</h3>
Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.
В приведённом ниже коде worker.slow() перестаёт работать после применения декоратора:
// сделаем worker.slow кеширующим
let worker = {
    someMethod() {
      return 1;
    },
    slow(x) {
      console.log("Called with " + x);
      return x * this.someMethod(); // (*)
    }
  };

function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) return cache.get(x);
        
        let result = func(x); // (**)
        cache.set(x, result);
        return result;
    }
}

console.log(worker.slow(5)); // оригинальный метод работает

worker.slow = cachingDecorator(worker.slow); 
console.log(worker.slow(5)); // TypeError: Cannot read property 'someMethod' of undefined


Ошибка возникает в строке (*). Функция пытается получить доступ к this.someMethod.
Причина в том, что в строке (**) декоратор вызывает оригинальную функцию.
как func(x), и она в данном случае получает this = undefined.

Мы бы наблюдали похожую ситуацию, если бы попытались запустить:
	let func = worker.slow;
	func(2);

Т.е. декоратор передаёт вызов оригинальному методу, но без контекста. Следовательно – ошибка.	


Существует специальный встроенный метод функции func.call(context, …args), 
который позволяет вызывать функцию, явно устанавливая this.
func.call(context, arg1, arg2, ...)

Исправим строку (**) в коде выше:
let result = func.call(this, x); // теперь 'this' передаётся правильно
При выполнении worker.slow(5) обёртка получает 5 в качестве аргумента и 
this=worker (так как это объект перед точкой).


Здесь используется call для вызова say с заданным контекстом и фразой:
	function say(phrase) {
 	  alert(this.name + ': ' + phrase);
	}

	let user = { name: "John" };

	// 'user' становится 'this', и "Hello" становится первым аргументом
	say.call( user, "Hello" ); // John: Hello

<h3>Переходим к нескольким аргументам с «func.apply»</h3>
Чтобы кешировать метод с несколькими аргументами worker.slow, можно соединить два 
значения в одно. В данном случае можно использовать строку "min,max" как ключ к Map. 
Также понадобится заменить func.call(this, x) на func.call(this, ...arguments).

let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments); // (**)

    cache.set(key, result);
    return result;
  };
}

function hash(...args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // работает
alert( "Again " + worker.slow(3, 5) ); // аналогично (из кеша)


Вместо func.call(this, ...arguments) можно было написать func.apply(this, arguments).

Синтаксис встроенного метода func.apply:
func.apply(context, args)

Разница в синтаксисе между call и apply состоит в том, что call ожидает 
список аргументов, в то время как apply принимает псевдомассив.


Передача всех аргументов вместе с контекстом другой функции называется 
«перенаправлением вызова» (call forwarding).
Простейший вид такого перенаправления:
	let wrapper = function() {
 	  return func.apply(this, arguments);
	};

<h3>Заимствование метода</h3>
function hash() {
  alert( arguments.join() ); // Ошибка: arguments.join не является функцией
}

function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

Мы берём (заимствуем) метод join из обычного массива [].join. И используем [].join.call, 
чтобы выполнить его в контексте arguments.

Это связано с тем, что внутренний алгоритм встроенного метода arr.join(glue) очень прост:

Пускай первым аргументом будет glue или, в случае отсутствия аргументов, им будет запятая ","
Пускай result будет пустой строкой "".
Добавить this[0] к result.
Добавить glue и this[1].
Добавить glue и this[2].
…выполнять до тех пор, пока this.length элементов не будет склеено.
Вернуть result.

ИТОГО:
func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
func.apply(context, args) – вызывает func, передавая context как this и 
псевдомассив args как список аргументов.

<p class='new-chapter' id="6.10">Привязка контекста к функции</p>	
<h3>Потеря «this»</h3>
Как только метод передаётся отдельно от объекта – this теряется.
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};
setTimeout(user.sayHi, 1000); // Привет, undefined!

То есть последняя строка может быть переписана как:
let f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли

Решение 1: сделать функцию-обёртку
	setTimeout(function() {
	  user.sayHi(); // Привет, Вася!
	}, 1000);

Однако, если до момента срабатывания setTimeout в переменную user будет 
записано другое значение, тогда вызов будет совсем не тот!

<h3>Решение 2: привязать контекст с помощью bind</h3>
Базовый синтаксис bind:
let boundFunc = func.bind(context);

	let user = {
  	  firstName: "Вася"
	};
	function f() {
 	   console.log(this.firstName);
	}
	let func = f.bind(user);
	func(); // Вася

Если у объекта много методов и мы планируем их активно передавать, 
то можно привязать контекст для них всех в цикле:
	for (let key in user) {
  	  if (typeof user[key] == 'function') {
   	   user[key] = user[key].bind(user);
  	  }
	}
Некоторые JS-библиотеки предоставляют встроенные функции для 
удобной массовой привязки контекста, например _.bindAll(obj) в lodash.

<h3>Частичное применение</h3>
Частичное применение - это создание новой функции с фиксированием одного 
или нескольких из существующих параметров.
Полный синтаксис bind:
let bound = func.bind(context, [arg1], [arg2], ...);

	function mul(a, b) {
  	  return a * b;
	}
	let double = mul.bind(null, 2); // создаём новую функцию double, 
которая передаёт вызов mul, фиксируя null как контекст, и 2 – как первый аргумент. 
Следующие аргументы передаются как есть.
	alert( double(3) ); // = mul(2, 3) = 6
	alert( double(4) ); // = mul(2, 4) = 8

<h3>Частичное применение без контекста</h3>
Встроенный bind не позволяет зафиксировать некоторые аргументы, без контекста.
В таком случае можно создать вспомогательную функцию, которая будет привязывать 
только аргумены. Также есть готовый вариант _.partial из библиотеки lodash.
Пример:
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}

	let user = {
 	  firstName: "John",
 	  say(time, phrase) {
  	    alert(`[${time}] ${this.firstName}: ${phrase}!`);
 	 }
	};

	// добавляем частично применённый метод с фиксированным временем
	user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

	user.sayNow("Hello"); // [10:00] John: Hello!

<p class='new-chapter' id="6.11">Каррирование</p>
Каррирование – это трансформация функций таким образом, 
чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).

Каррирование не вызывает функцию. Оно просто трансформирует её.
Создадим вспомогательную функцию curry(f), которая выполняет каррирование функции f с 
двумя аргументами. Другими словами, curry(f) для функции f(a, b) трансформирует её в f(a)(b).
  function curry(f) { // curry(f) выполняет каррирование
	return function(a) {
	  return function(b) {
		return f(a, b);
	  };
	};
  }
  
  // использование
  function sum(a, b) {
	return a + b;
  }
  
  let carriedSum = curry(sum);
  
  console.log( carriedSum(1)(2) ); // 3

Более продвинутые реализации каррирования, как например _.curry из библиотеки lodash, 
возвращают обёртку, которая позволяет запустить функцию как обычным образом, так и частично:
  function sum(a, b) {
	return a + b;
  }
  
  let carriedSum = _.curry(sum); // используем _.curry из lodash
  
  alert( carriedSum(1, 2) ); // 3, можно вызывать как обычно
  alert( carriedSum(1)(2) ); // 3, а можно частично

<h3>Продвинутая реализация каррирования</h3>
Без привязки контекста:
function curry(func) {
    return function curried(...args) {
        if (args.length >= func.length) {
            return func(...args); // выполнится только когда curried накопит достаточно args
        } else {
            return function(...args2) {
                return curried(...args, ...args2);
            }
        }
    }
}

Универсальная реализация:
function curry(func) {

	return function curried(...args) {
	  if (args.length >= func.length) {
		return func.apply(this, args);
	  } else {
		return function(...args2) {
		  return curried.apply(this, args.concat(args2));
		}
	  }
	};
  
}

<h3>Каррирование? Зачем?</h3>
Пускай есть функция:
  function log(date, importance, message) {
	alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
  }

  log = _.curry(log); // применим к ней каррирование

  log(new Date(), "DEBUG", "some debug"); // продолжает работать нормально
  log(new Date())("DEBUG")("some debug"); // а также работает с вариант с каррированием

Теперь сделаем удобную функцию для логов с текущим временем:
	let logNow = log(new Date()); // частичное применение функции log с фиксированным первым аргументом

	logNow("INFO", "message"); // [HH:mm] INFO message
// Теперь logNow – это log с фиксированным первым аргументом, то есть, «частично применённая» функция.
Можно пойти дальше и сделать удобную функцию для именно отладочных логов с текущим временем:
	let debugNow = logNow("DEBUG");


Итак:
Мы ничего не потеряли после каррирования: log всё так же можно вызывать нормально.
Мы можем легко создавать частично применённые функции, как сделали для логов с текущим временем.

<p class='new-chapter' id="6.12">Повторяем стрелочные функции</p>
<h3>У стрелочных функций нет «this»</h3>
Это можно использовать для итерации внутри метода объекта:

let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
  }
};
// Если бы вместо стрелочной использовалась обычная функция, то возникла бы ошибка

<h3>Стрелочные функции нельзя использовать с new</h3>
Отсутствие this естественным образом ведёт к другому ограничению: стрелочные функции 
не могут быть использованы как конструкторы. Они не могут быть вызваны с new.

	let User = () => {
   	 this.name = "John";
	}

	let user = new User(); // TypeError: User is not a constructor

<h3>Стрелочные функции не имеют «arguments»</h3>
У стрелочных функций также нет переменной arguments.

(У них также нет super, но про это будет в главе Наследование классов).	

		</pre>
	</main>
</body>
</html>